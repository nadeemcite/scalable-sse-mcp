{{- if .Values.nginx.enabled | default false }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "nginx.fullname" . }}-config
data:
  nginx.conf: |
    worker_processes 1;
    events { worker_connections 1024; }
    http {
      lua_package_path "/usr/local/openresty/lualib/?.lua;;";
      lua_shared_dict my_cache 10m;

      resolver 10.96.0.10 valid=30s;
      resolver_timeout 5s;

      # stream immediately to client
      proxy_buffering    off;
      proxy_http_version 1.1;
      proxy_set_header   Connection "";
      proxy_read_timeout 60s;
      send_timeout       60s;

      upstream fastapi_hash {
        hash $arg_sessionid consistent;
        {{- $replicas := .Values.replicaCount | default 0 | int }}
        {{- range $i := until $replicas }}
        server {{ include "fastapi-stateful.fullname" $ }}-{{ $i }}.{{ include "fastapi-stateful.fullname" $ }}-headless.{{ $.Release.Namespace }}.svc.cluster.local:{{ $.Values.service.port }};
        {{- end }}
      }

      server {
        listen {{ .Values.nginx.service.port }};
        set $target '';

        # ─────────────────────────────────────────
        # 1) SSE endpoint: extract sessionId from the event-stream
        # ─────────────────────────────────────────
        location = /sse {
          proxy_pass http://fastapi_hash;
          proxy_set_header Host              $host;
          proxy_set_header X-Real-IP         $remote_addr;
          proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;

          header_filter_by_lua_block {
            -- prepare to buffer only until we find the endpoint event
            ngx.ctx.sse_buf    = ""
            ngx.ctx.sse_done   = false
          }

          body_filter_by_lua_block {
            local chunk = ngx.arg[1] or ""
            -- always forward to client
            ngx.arg[1] = chunk

            if not ngx.ctx.sse_done then
              -- accumulate until we spot the `event: endpoint` block
              ngx.ctx.sse_buf = ngx.ctx.sse_buf .. chunk

              -- look for:
              --   event: endpoint
              --   data: /message?sessionId=…
              local data = ngx.ctx.sse_buf:match(
                "event:%s*endpoint%s-[\r\n]+data:%s*(.-)[\r\n]+"
              )
              
              if data then
                -- extract the UUID
                ngx.log(ngx.ERR, "sessionId: ", data)
                local sessionid = data:match("session_id=([%w%-]+)")
                ngx.log(ngx.ERR, "sessionId: ", sessionid)
                if sessionid then
                  ngx.log(ngx.ERR, "[SSE] got sessionId: ", sessionid)
                  local upstream_addr = ngx.var.upstream_addr or "unknown"

                  -- schedule Redis SETEX in a timer (cosocket forbidden in filter)
                  ngx.timer.at(0, function(premature)
                    if premature then return end
                    local redis = require "resty.redis"
                    local r     = redis:new()
                    r:set_timeout(1000)
                    local ok, err = r:connect(
                      "{{ include "redis.fullname" . }}-master.{{ .Release.Namespace }}.svc.cluster.local",
                      {{ .Values.redis.port }}
                    )
                    if ok then
                      r:setex(sessionid, 86400, upstream_addr)
                    else
                      ngx.log(ngx.ERR, "[SSE] redis connect error: ", err)
                    end
                  end)

                  -- done, drop buffer
                  ngx.ctx.sse_done = true
                  ngx.ctx.sse_buf  = nil
                end
              end
            end
          }
        }

        # ─────────────────────────────────────────
        # 2) All other routes: expect ?sessionid, lookup Redis, then proxy
        # ─────────────────────────────────────────
        location / {
          content_by_lua_block {
            local redis = require "resty.redis"
            local r     = redis:new()
            r:set_timeout(1000)
            local ok, err = r:connect(
              "{{ include "redis.fullname" . }}-master.{{ .Release.Namespace }}.svc.cluster.local",
              {{ .Values.redis.port }}
            )
            if not ok then
              ngx.status = 500
              ngx.say("Redis error: ", err)
              return
            end

            local sessionid = ngx.var.arg_session_id
            if not sessionid then
              ngx.status = 400
              ngx.say("Missing sessionid")
              return
            end

            local upstream = r:get(sessionid)
            if upstream == ngx.null or not upstream then
              ngx.status = 404
              ngx.say("No upstream for sessionid")
              return
            end

            ngx.var.target = "http://" .. upstream
            return ngx.exec("@proxy")
          }
        }

        location @proxy {
          proxy_pass $target;
          proxy_set_header Host            $host;
          proxy_set_header X-Real-IP       $remote_addr;
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
      }
    }
{{- end }}